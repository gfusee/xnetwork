package path

import (
	"fmt"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"sync"
)

const maxAllowedChainIDsDirectories = 1
const maxAllowedShardIDs = 1
const staticPath = "Static"
const epochPathPart = "Epoch_"
const shardPathPart = "Shard_"

type parser struct {
	dbRootPath     string
	dirReadHandler func(name string) ([]os.DirEntry, error)

	mutData               sync.RWMutex
	chainID               string
	highestEpoch          uint64
	lowestContinuousEpoch uint64
	foundStatic           bool
	shardID               uint64
}

// NewParser creates a new instance of path parser able to determine the components
// of a db path generated by the node
// db path example:
// db/1/Epoch_724/Shard_0/...
func NewParser(dbRootPath string) *parser {
	return &parser{
		dbRootPath:     dbRootPath,
		dirReadHandler: os.ReadDir,
	}
}

// ParseDirectory will parse the root path directory and figure out the
// chain ID, epoch and shard ID. It also checks the consistency of the sub-directories contained
func (p *parser) ParseDirectory() error {
	var err error

	p.mutData.Lock()
	defer p.mutData.Unlock()

	p.resetData()

	currentPath := p.dbRootPath
	directories, err := p.readDirectories(currentPath)
	if err != nil {
		return err
	}
	if len(directories) != maxAllowedChainIDsDirectories {
		return errInvalidNumOfChainIDsFound
	}
	p.chainID = directories[0].Name()

	currentPath = path.Join(currentPath, p.chainID)
	directories, err = p.readDirectories(currentPath)
	if err != nil {
		return err
	}

	err = p.processEpochs(directories)
	if err != nil {
		return err
	}

	return p.processShardID(currentPath)
}

func (p *parser) resetData() {
	p.chainID = ""
	p.highestEpoch = 0
	p.lowestContinuousEpoch = 0
	p.foundStatic = false
	p.shardID = 0
}

func (p *parser) readDirectories(path string) ([]os.DirEntry, error) {
	entries, err := p.dirReadHandler(path)
	if err != nil {
		return nil, err
	}

	return p.filterOnlyDirectories(entries), nil
}

func (p *parser) filterOnlyDirectories(dirEntries []os.DirEntry) []os.DirEntry {
	result := make([]os.DirEntry, 0, len(dirEntries))
	for _, dirEntry := range dirEntries {
		if dirEntry.IsDir() {
			result = append(result, dirEntry)
		}
	}

	return result
}

func (p *parser) processEpochs(directories []os.DirEntry) error {
	epochs := make([]int, 0, len(directories))

	for _, dir := range directories {
		if dir.Name() == staticPath {
			p.foundStatic = true
			continue
		}

		if strings.Index(dir.Name(), epochPathPart) != 0 {
			continue
		}

		epochValueString := dir.Name()[len(epochPathPart):]
		epochValue, err := strconv.Atoi(epochValueString)
		if err != nil {
			continue
		}

		epochs = append(epochs, epochValue)
	}

	if len(epochs) == 0 {
		return errNoEpochDirectoryFound
	}

	sort.Slice(epochs, func(i, j int) bool {
		return epochs[i] > epochs[j]
	})

	p.highestEpoch = uint64(epochs[0])
	p.lowestContinuousEpoch = uint64(epochs[0])
	for i := 1; i < len(epochs); i++ {
		if epochs[i] == int(p.lowestContinuousEpoch)-1 {
			p.lowestContinuousEpoch--
			continue
		}

		break
	}

	return nil
}

func (p *parser) processShardID(currentPath string) error {
	if !p.foundStatic {
		return errMissingStaticDirectory
	}
	completeStaticPath := path.Join(currentPath, staticPath)
	directories, err := p.readDirectories(completeStaticPath)
	if err != nil {
		return err
	}
	if len(directories) != maxAllowedShardIDs {
		return errInvalidNumOfShardIDsFound
	}
	dir := directories[0]
	if strings.Index(dir.Name(), shardPathPart) != 0 {
		return fmt.Errorf("%w, found path %s", errInvalidShardIDDirectory, dir.Name())
	}
	shardIDStr := dir.Name()[len(shardPathPart):]
	shardID, err := strconv.Atoi(shardIDStr)
	if err != nil {
		return fmt.Errorf("%w, found path %s, inner error %s", errInvalidShardIDDirectory, dir.Name(), err.Error())
	}
	p.shardID = uint64(shardID)

	return nil
}

// ChainID returns the parsed chain ID string
func (p *parser) ChainID() string {
	p.mutData.RLock()
	defer p.mutData.RUnlock()

	return p.chainID
}

// HighestEpoch returns the highest parsed epoch value
func (p *parser) HighestEpoch() uint64 {
	p.mutData.RLock()
	defer p.mutData.RUnlock()

	return p.highestEpoch
}

// LowestContinuousEpoch returns the lowest continuous epoch in respect with the HighestEpoch value
func (p *parser) LowestContinuousEpoch() uint64 {
	p.mutData.RLock()
	defer p.mutData.RUnlock()

	return p.lowestContinuousEpoch
}

// ShardID returns the parsed shard ID value
func (p *parser) ShardID() uint64 {
	p.mutData.RLock()
	defer p.mutData.RUnlock()

	return p.shardID
}
